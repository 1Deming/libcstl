<!DOCTYPE html>
<html lang="zh">
  <head>
    <title>libcstl | manual</title>
    <meta name="viewpoint" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta name="description" content="libcstl开源项目" />
    <meta name="keywords" content="stl, c, c++, data structure, algorithm, SGI, container, iterator" />
    <meta name="keywords" content="数据结构, 算法, 容器, 迭代器" lang="zh" />
    <meta name="robots" content="all" />
    <meta name="author" content="activesys.wb@gmail.com" />
    <meta name="copyright" content="http://libcstl.org" />
    <link rel="stylesheet" type="text/css" href="../../bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../../bootstrap/css/bootstrap-responsive.min.css">
    <link rel="stylesheet" type="text/css" href="../../stylesheets/libcstl.css">
    <link rel="stylesheet" type="text/css" href="../../google-code-prettify/desert.css">
  </head>
  <body data-spy="scroll" data-target=".bs-docs-sidebar" onload="prettyPrint()">
    <div id="bs-docs-top"></div>

    <div class="navbar-fixed-top">
        <div class="container">
          <ul class="breadcrumb">
            <li><a class="brand" href="http://libcstl.org/">libcstl</a> <span class="divider">/</span></li>
            <li><a href="../../docs.html">文档</a> <span class="divider">/</span></li>
            <li class="active">参考手册</li>
            <li class="bs-docs-top"><a title="to top" href="#bs-docs-top"><i class="icon-arrow-up"></i></a></li>
          </ul>
        </div>
    </div>

    <div class="container">
      <div class="row">
        <div class="span3 bs-docs-sidebar">
          <ul class="nav nav-list bs-docs-sidenav affix-top">
            <li class="bs-docs-first-item"><a href="#introduce"><i class="icon-chevron-right"></i>1. 简介</a></li>
            <li><a href="#container"><i class="icon-chevron-right"></i>2. 容器</a></li>
              <ul class="nav nav-list bs-docs-subsidenav">
                <li><a href="#deque_t"><i class="icon-chevron-right"></i>2.1. deque_t</a></li>
              </ul>
            <li><a href="#iterator"><i class="icon-chevron-right"></i>3. 迭代器</a></li>
            <li><a href="#algorithm"><i class="icon-chevron-right"></i>4. 算法</a></li>
            <li><a href="#function"><i class="icon-chevron-right"></i>5. 函数</a></li>
            <li><a href="#string"><i class="icon-chevron-right"></i>6. 字符串</a></li>
            <li><a href="#utils"><i class="icon-chevron-right"></i>7. 工具类型</a></li>
            <li class="bs-docs-last-item"><a href="#type-mechanism"><i class="icon-chevron-right"></i>8. 类型机制</a></li>
          </ul>
        </div>

        <div class="span9">
          <section class="bs-docs-title">
            参考手册 
          </section>

          <!-- introduce -->
          <section id="introduce">
            <div class="page-header">
              <h1>1. 简介</h1>
            </div>
            <p>
              这本手册详细的描述了libcstl的全部接口和数据结构，详细的介绍了每个函数和算法的参数和返回值。
              这本手册并没有介绍关于使用技巧方面的内容，如果想要了解使用技巧方面的内容请参考<a href="../tutorial/tutorial.html">《教程》</a>。
            </p>
            <p>
              要使用libcstl提供的函数、迭代器、算法和函数，需要包含特定的头文件，下面列举了libcstl提供的全部头文件及其简要的说明：
            </p>
            <table class="table table-striped table-bordered">
              <caption>表1-1 libcstl头文件</caption>
              <thead>
                <tr>
                  <th>头文件</th>
                  <th>简要描述</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>calgorithm.h</td>
                  <td>定义了除了数值算法之外的其他算法</td>
                </tr>
                <tr>
                  <td>cdeque.h</td>
                  <td>定义了双端队列容器及其操作函数</td>
                </tr>
                <tr>
                  <td>cfunctional.h</td>
                  <td>定义了函数和谓词</td>
                </tr>
                <tr>
                  <td>chash_map.h</td>
                  <td>定义了基于哈希结构的映射和多重映射容器及其操作函数</td>
                </tr>
                <tr>
                  <td>chash_set.h</td>
                  <td>定义了基于哈希结构的集合和多重集合容器及其操作函数</td>
                </tr>
                <tr>
                  <td>citerator.h</td>
                  <td>定义了迭代器和迭代器辅助函数</td>
                </tr>
                <tr>
                  <td>clist.h</td>
                  <td>定义了双向链表容器及其操作函数</td>
                </tr>
                <tr>
                  <td>cmap.h</td>
                  <td>定义了映射和多重映射容器及其操作函数</td>
                </tr>
                <tr>
                  <td>cnumeric.h</td>
                  <td>定义了数值算法</td>
                </tr>
                <tr>
                  <td>cqueue.h</td>
                  <td>定义了队列和优先队列容器适配器及其操作函数</td>
                </tr>
                <tr>
                  <td>cset.h</td>
                  <td>定义了集合和多重集合容器及其操作函数</td>
                </tr>
                <tr>
                  <td>cslist.h</td>
                  <td>定义了单向链表容器及其操作函数</td>
                </tr>
                <tr>
                  <td>cstack.h</td>
                  <td>定义了堆栈容器适配器及其操作函数</td>
                </tr>
                <tr>
                  <td>cstring.h</td>
                  <td>定义了字符串类型及其操作函数</td>
                </tr>
                <tr>
                  <td>cutility.h</td>
                  <td>定义了工具类型及其操作函数</td>
                </tr>
                <tr>
                  <td>cvector.h</td>
                  <td>定义了向量容器及其操作函数</td>
                </tr>
              </tbody>
            </table>
          </section>

          <!-- container -->
          <section id="container">
            <div class="page-header">
              <h1>2. 容器</h1>
            </div>
            <p>
              libcstl容器分为三种类型：序列容器、关联容器和容器适配器。
            </p>
            <ul>
              <li>
                序列容器：序列容器按照数据插入的次序来保存数据。
              </li>
            </ul>
            <table class="table table-striped table-bordered">
              <caption>表2-1 libcstl序列容器</caption>
              <thead>
                <tr>
                  <th>容器类型</th>
                  <th>简要描述</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><a href="deque_t.html">deque_t</a></td>
                  <td>双端队列允许在队列的两端快速的插入和删除数据，允许随机访问数据</td>
                </tr>
                <tr>
                  <td><a href="list_t.html">list_t</a></td>
                  <td>双向链表允许在链表的任何位置快速的插入和删除数据，但是不能够随机访问数据</td>
                </tr>
                <tr>
                  <td><a href="vector_t.html">vector_t</a></td>
                  <td>向量类似于数组，可以根据需要自动增长</td>
                </tr>
                <tr>
                  <td><a href="slist_t.html">slist_t</a></td>
                  <td>单向链表是一个弱化的链表，只允许在链表的开头快速的插入和删除数据，也不支持随机访问</td>
                </tr>
              </tbody>
            </table>
            <ul>
              <li>
                关联容器：关联容器将插入的数据自动排序。关联容器分为两大类，映射和集合。映射保存的是键/值对，
                映射中的数据是根据键来排序的。集合保存着有序的数据，数据本身就是键。映射和集合中的键都不能够重复，
                要想保存重复的键就要使用多重映射和多重集合。libcstl还提供了基于哈希结构的映射和集合。
              </li>
            </ul>
            <table class="table table-striped table-bordered">
              <caption>表2-2 libcstl关联容器</caption>
              <thead>
                <tr>
                  <th>容器类型</th>
                  <th>简要描述</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><a href="map_t.html">map_t</a></td>
                  <td>映射容器，保存有序的键/值对，键不能重复</td>
                </tr>
                <tr>
                  <td><a href="multimap_t.html">multimap_t</a></td>
                  <td>多重映射容器，保存有序的键/值对，键可以重复</td>
                </tr>
                <tr>
                  <td><a href="set_t.html">set_t</a></td>
                  <td>集合容器，保存有序的数据，数据不能重复</td>
                </tr>
                <tr>
                  <td><a href="multiset_t.html">multiset_t</a></td>
                  <td>多重集合容器，保存有序的数据，数据可以重复</td>
                </tr>
                <tr>
                  <td><a href="hash_map_t.html">hash_map_t</a></td>
                  <td>基于哈希结构额映射容器，保存有序的键/值对，键不能重复</td>
                </tr>
                <tr>
                  <td><a href="hash_multimap_t.html">hash_multimap_t</a></td>
                  <td>基于哈希结构的多重映射容器，保存有序的键/值对，键可以重复</td>
                </tr>
                <tr>
                  <td><a href="hash_set_t.html">hash_set_t</a></td>
                  <td>基于哈希结构的集合容器，保存有序的数据，数据不能重复</td>
                </tr>
                <tr>
                  <td><a href="hash_multiset_t.html">hash_multiset_t</a></td>
                  <td>基于哈希结构的多重集合容器，保存有序的数据，数据可以重复</td>
                </tr>
              </tbody>
            </table>
            <ul>
              <li>
                容器适配器：容器适配器是对容器进行了简单的封装，它们的底层实现都是容器，但是容器适配器不支持迭代器。
              </li>
            </ul>
            <table class="table table-striped table-bordered">
              <caption>表2-3 libcstl容器适配器</caption>
              <thead>
                <tr>
                  <th>容器适配器类型</th>
                  <th>简要描述</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><a href="stack_t.html">stack_t</a></td>
                  <td>它实现了一个后入先出(LIFO)的语义，最后被插入的数据第一个被删除</td>
                </tr>
                <tr>
                  <td><a href="queue_t.html">queue_t</a></td>
                  <td>它实现了一个先入先出(LIFO)的语义，第一个被插入的数据也第一个被删除</td>
                </tr>
                <tr>
                  <td><a href="priority_queue_t.html">priority_queue_t</a></td>
                  <td>它是含有优先级的队列，优先级最高的数据总是在队列的最前面</td>
                </tr>
              </tbody>
            </table>
          </section>

          <!-- deque_t -->
          <section id="deque_t">
            <div class="page-header">
              <h2>2.1. deque_t</h2>
            </div>
            <p>
              双端队列容器deque_t使用线性的方式保存数据，它允许对数据的随机访问，以及在队列的两端高效的插入或删除数据。
            </p>
            <ul><li>类型定义</li></ul>
            <table class="table table-striped table-bordered">
              <caption>表2-1-1 双端队列deque_t容器类型定义</caption>
              <thead>
                <tr>
                  <th>类型定义</th>
                  <th>简要描述</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><a href="deque_t.html#deque_t">deque_t</a></td>
                  <td>双端队列容器类型</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_iterator_t">deque_iterator_t</a></td>
                  <td>双端队列容器对应的迭代器类型</td>
                </tr>
              </tbody>
            </table>
            <ul><li>操作函数</li></ul>
            <table class="table table-striped table-bordered">
              <caption>表2-1-2 双端队列deque_t容器操作函数</caption>
              <thead>
                <tr>
                  <th>操作函数</th>
                  <th>简要描述</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><a href="deque_t.html#create_deque">create_deque</a></td>
                  <td>创建一个双端队列容器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_assign">deque_assign</a></td>
                  <td>给双端队列容器赋值</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_assign_array">deque_assign_array</a></td>
                  <td>使用指定的数组给双端队列容器赋值</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_assign_elem">deque_assign_elem</a></td>
                  <td>使用指定数据给双端队列容器赋值</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_assign_range">deque_assign_range</a></td>
                  <td>使用指定范围的数据给双端队列容器赋值</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_at">deque_at</a></td>
                  <td>使用下标访问双端队列容器中的数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_back">deque_back</a></td>
                  <td>访问双端队列容器的最后一个数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_begin">deque_begin</a></td>
                  <td>返回指向双端队列容器中的第一个数据的迭代器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_clear">deque_clear</a></td>
                  <td>删除双端队列容器中的所有数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_destroy">deque_destroy</a></td>
                  <td>销毁双端队列容器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_empty">deque_empty</a></td>
                  <td>测试双端队列容器是否为空</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_end">deque_end</a></td>
                  <td>返回指向双端队列容器末尾的迭代器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_equal">deque_equal</a></td>
                  <td>测试两个双端队列容器是否相等</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_erase">deque_erase</a></td>
                  <td>删除双端队列容器中指定位置的数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_erase_range">deque_erase_range</a></td>
                  <td>删除双端队列容器中指定范围的数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_front">deque_front</a></td>
                  <td>访问双端队列容器中的第一个数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_greater">deque_greater</a></td>
                  <td>测试第一个双端队列容器是否大于第二个双端队列容器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_greater_equal">deque_greater_equal</a></td>
                  <td>测试第一个双端队列容器是否大于等于第二个双端队列容器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_init">deque_init</a></td>
                  <td>初始化一个空的双端队列容器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_init_copy">deque_init_copy</a></td>
                  <td>双端队列容器拷贝初始化函数</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_init_copy_array">deque_init_copy_array</a></td>
                  <td>使用数组初始化双端队列容器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_init_copy_range">deque_init_copy_range</a></td>
                  <td>使用指定范围初始化双端队列容器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_init_elem">deque_init_elem</a></td>
                  <td>使用指定数据初始化双端队列容器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_init_n">deque_init_n</a></td>
                  <td>使用指定个数的默认数据初始化双端队列容器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_insert">deque_insert</a></td>
                  <td>在指定的位置插入数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_insert_array">deque_insert_array</a></td>
                  <td>在指定的位置插入数组中的数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_insert_range">deque_insert_range</a></td>
                  <td>在指定的位置插入指定区间的数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_insert_n">deque_insert_n</a></td>
                  <td>在指定的位置插入多个数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_less">deque_less</a></td>
                  <td>测试第一个双端队列容器是否小于第二个双端队列容器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_less_equal">deque_less_equal</a></td>
                  <td>测试第一个双端队列容器是否小于等于第二个双端队列容器</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_max_size">deque_max_size</a></td>
                  <td>返回双端队列容器的最大可能长度</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_not_equal">deque_not_equal</a></td>
                  <td>测试两个双端队列容器是否不等</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_pop_back">deque_pop_back</a></td>
                  <td>删除双端队列容器的最后一个数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_pop_front">deque_pop_front</a></td>
                  <td>删除双端队列容器的第一个数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_push_back">deque_push_back</a></td>
                  <td>在双端队列容器的末尾添加一个数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_push_front">deque_push_front</a></td>
                  <td>在双端队列容器的开头添加一个数据</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_resize">deque_resize</a></td>
                  <td>指定双端队列容器的长度，使用默认数据填充</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_resize_elem">deque_resize_elem</a></td>
                  <td>指定双端队列容器的长度，使用指定数据填充</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_size">deque_size</a></td>
                  <td>返回双端队列容器中数据的个数</td>
                </tr>
                <tr>
                  <td><a href="deque_t.html#deque_swap">deque_swap</a></td>
                  <td>交换两个双端队列容器中的数据</td>
                </tr>
              </tbody>
            </table>
          </section>

          <!-- iterator -->
          <section id="iterator">
            <div class="page-header">
              <h1>3. 迭代器</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- algorithm -->
          <section id="algorithm">
            <div class="page-header">
              <h1>4. 算法</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- function -->
          <section id="function">
            <div class="page-header">
              <h1>5. 函数</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- string -->
          <section id="string">
            <div class="page-header">
              <h1>6. 字符串</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- utils -->
          <section id="utils">
            <div class="page-header">
              <h1>7. 工具类型</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- type-mechanism -->
          <section id="type-mechanism">
            <div class="page-header">
              <h1>8. 类型机制</h1>
            </div>
            <p>
            </p>
          </section>
        </div>
      </div>

      <hr>
      <footer>
        <p id="copyright">
          &copy; 2008 - 2014
          <a href="http://libcstl.org/">libcstl.org</a>
        </p>
        <p id="github">
          Published with
          <a href="http://pages.github.com">Github Pages</a>
        </p>
      </footer>
    </div>

    <script src="../../javascripts/jquery-1.11.0.min.js"></script>
    <script src="../../bootstrap/js/bootstrap.min.js"></script>
    <script src="../../google-code-prettify/prettify.js"></script>
  </body>
</html>

