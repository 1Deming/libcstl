<!DOCTYPE html>
<html lang="zh">
  <head>
    <title>libcstl | manual</title>
    <meta name="viewpoint" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta name="description" content="libcstl开源项目" />
    <meta name="keywords" content="stl, c, c++, data structure, algorithm, SGI, container, iterator" />
    <meta name="keywords" content="数据结构, 算法, 容器, 迭代器" lang="zh" />
    <meta name="robots" content="all" />
    <meta name="author" content="activesys.wb@gmail.com" />
    <meta name="copyright" content="http://libcstl.org" />
    <link rel="stylesheet" type="text/css" href="../../bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="../../bootstrap/css/bootstrap-responsive.min.css">
    <link rel="stylesheet" type="text/css" href="../../stylesheets/libcstl.css">
    <link rel="stylesheet" type="text/css" href="../../google-code-prettify/desert.css">
  </head>
  <body data-spy="scroll" data-target=".bs-docs-sidebar" onload="prettyPrint()">
    <div id="bs-docs-top"></div>

    <div class="navbar-fixed-top">
        <div class="container">
          <ul class="breadcrumb">
            <li><a class="brand" href="http://libcstl.org/">libcstl</a> <span class="divider">/</span></li>
            <li><a href="../../docs.html">文档</a> <span class="divider">/</span></li>
            <li><a href="manual.html">参考手册</a> <span class="divider">/</span></li>
            <li class="active">deque_t</li>
            <li class="bs-docs-top"><a title="to top" href="#bs-docs-top"><i class="icon-arrow-up"></i></a></li>
          </ul>
        </div>
    </div>

    <div class="container">
      <div class="row">
        <div class="span3 bs-docs-sidebar">
          <ul class="nav nav-list bs-docs-sidenav affix-top">
            <li class="bs-docs-first-item"><a href="#deque_t"><i class="icon-chevron-right"></i>deque_t</a></li>
            <li><a href="#deque_iterator_t"><i class="icon-chevron-right"></i>deque_iterator_t</a></li>
            <li><a href="#create_deque"><i class="icon-chevron-right"></i>create_deque</a></li>
            <li><a href="#deque_assign"><i class="icon-chevron-right"></i>deque_assign</a></li>
            <li><a href="#deque_assign_array"><i class="icon-chevron-right"></i>deque_assign_array</a></li>
            <li><a href="#deque_assign_elem"><i class="icon-chevron-right"></i>deque_assign_elem</a></li>
            <li><a href="#deque_assign_range"><i class="icon-chevron-right"></i>deque_assign_range</a></li>
            <li><a href="#deque_at"><i class="icon-chevron-right"></i>deque_at</a></li>
            <li><a href="#deque_back"><i class="icon-chevron-right"></i>deque_back</a></li>
            <li><a href="#deque_begin"><i class="icon-chevron-right"></i>deque_begin</a></li>
            <li><a href="#deque_clear"><i class="icon-chevron-right"></i>deque_clear</a></li>
            <li><a href="#deque_destroy"><i class="icon-chevron-right"></i>deque_destroy</a></li>
            <li><a href="#deque_empty"><i class="icon-chevron-right"></i>deque_empty</a></li>
            <li><a href="#deque_end"><i class="icon-chevron-right"></i>deque_end</a></li>
            <li><a href="#deque_equal"><i class="icon-chevron-right"></i>deque_equal</a></li>
            <li><a href="#deque_erase"><i class="icon-chevron-right"></i>deque_erase</a></li>
            <li><a href="#deque_erase_range"><i class="icon-chevron-right"></i>deque_erase_range</a></li>
            <li><a href="#deque_front"><i class="icon-chevron-right"></i>deque_front</a></li>
            <li><a href="#deque_greater"><i class="icon-chevron-right"></i>deque_greater</a></li>
            <li><a href="#deque_greater_equal"><i class="icon-chevron-right"></i>deque_greater_equal</a></li>
            <li><a href="#deque_init"><i class="icon-chevron-right"></i>deque_init</a></li>
            <li><a href="#deque_init_copy"><i class="icon-chevron-right"></i>deque_init_copy</a></li>
            <li><a href="#deque_init_copy_array"><i class="icon-chevron-right"></i>deque_init_copy_array</a></li>
            <li><a href="#deque_init_copy_range"><i class="icon-chevron-right"></i>deque_init_copy_range</a></li>
            <li><a href="#deque_init_elem"><i class="icon-chevron-right"></i>deque_init_elem</a></li>
            <li><a href="#deque_init_n"><i class="icon-chevron-right"></i>deque_init_n</a></li>
            <li><a href="#deque_insert"><i class="icon-chevron-right"></i>deque_insert</a></li>
            <li><a href="#deque_insert_array"><i class="icon-chevron-right"></i>deque_insert_array</a></li>
            <li><a href="#deque_insert_range"><i class="icon-chevron-right"></i>deque_insert_range</a></li>
            <li><a href="#deque_insert_n"><i class="icon-chevron-right"></i>deque_insert_n</a></li>
            <li><a href="#deque_less"><i class="icon-chevron-right"></i>deque_less</a></li>
            <li><a href="#deque_less_equal"><i class="icon-chevron-right"></i>deque_less_equal</a></li>
            <li><a href="#deque_max_size"><i class="icon-chevron-right"></i>deque_max_size</a></li>
            <li><a href="#deque_not_equal"><i class="icon-chevron-right"></i>deque_not_equal</a></li>
            <li><a href="#deque_pop_back"><i class="icon-chevron-right"></i>deque_pop_back</a></li>
            <li><a href="#deque_pop_front"><i class="icon-chevron-right"></i>deque_pop_front</a></li>
            <li><a href="#deque_push_back"><i class="icon-chevron-right"></i>deque_push_back</a></li>
            <li><a href="#deque_push_front"><i class="icon-chevron-right"></i>deque_push_front</a></li>
            <li><a href="#deque_resize"><i class="icon-chevron-right"></i>deque_resize</a></li>
            <li><a href="#deque_resize_elem"><i class="icon-chevron-right"></i>deque_resize_elem</a></li>
            <li><a href="#deque_size"><i class="icon-chevron-right"></i>deque_size</a></li>
            <li class="bs-docs-last-item"><a href="#deque_swap"><i class="icon-chevron-right"></i>deque_swap</a></li>
          </ul>
        </div>

        <div class="span9">
          <!-- deque_t -->
          <section id="deque_t">
            <div class="page-header">
              <h1>deque_t</h1>
            </div>
            <ul class="bs-docs-subtitle"><li>类型描述</li></ul>
            <p>
              deque_t是双端队列容器类型。
            </p>
            <ul class="bs-docs-subtitle"><li>前提条件</li></ul>
            <p>
              包含头文件&lt;cstl/cdeque.h&gt;。
            </p>
            <ul class="bs-docs-subtitle"><li>版本</li></ul>
            <p>
              所有版本。
            </p>
            <ul class="bs-docs-subtitle"><li>示例代码</li></ul>
            <p>
              请参考其他deque_t其他操作函数。
            </p>
          </section>

          <!-- deque_iterator_t -->
          <section id="deque_iterator_t">
            <div class="page-header">
              <h1>deque_iterator_t</h1>
            </div>
            <ul class="bs-docs-subtitle"><li>类型描述</li></ul>
            <p>
              deque_iterator_t是双端队列容器的迭代器类型。
            </p>
            <ul class="bs-docs-subtitle"><li>备注</li></ul>
            <p>
              deque_iterator_t是随机访问迭代器类型，可以通过迭代器类修改容器中的数据。
            </p>
            <ul class="bs-docs-subtitle"><li>前提条件</li></ul>
            <p>
              包含头文件&lt;cstl/cdeque.h&gt;。
            </p>
            <ul class="bs-docs-subtitle"><li>版本</li></ul>
            <p>
              所有版本
            </p>
            <ul class="bs-docs-subtitle"><li>示例代码</li></ul>
            <p>
              请参考其他deque_t其他操作函数。
            </p>
          </section>

          <!-- create_deque -->
          <section id="create_deque">
            <div class="page-header">
              <h1>create_deque</h1>
            </div>
            <ul class="bs-docs-subtitle"><li>函数描述</li></ul>
            <p>
              创建一个双端队列容器。
            </p>
            <ul class="bs-docs-subtitle"><li>函数原型</li></ul>
<pre class="prettyprint">
deque_t* create_deque(type);
</pre>
            <ul class="bs-docs-subtitle"><li>参数说明</li></ul>
            <table class="table table-condensed">
              <tr>
                <th>type:</th>
                <td>数据类型描述。</td>
              </tr>
            </table>
            <ul class="bs-docs-subtitle"><li>备注</li></ul>
            <p>
              type必须是有效的数据类型描述，否则创建失败。
              创建成功返回指向deque_t类型的指针，失败返回NULL。
            </p>
            <ul class="bs-docs-subtitle"><li>前提条件</li></ul>
            <p>
              包含头文件&lt;cstl/cdeque.h&gt;
            </p>
            <ul class="bs-docs-subtitle"><li>版本</li></ul>
            <p>
              所有版本。
            </p>
            <ul class="bs-docs-subtitle"><li>示例代码</li></ul>
            <p>
              请参考其他deque_t其他操作函数。
            </p>
          </section>

          <!-- deque_assign -->
          <section id="deque_assign">
            <div class="page-header">
              <h1>deque_assign</h1>
            </div>
            <ul class="bs-docs-subtitle"><li>函数描述</li></ul>
            <p>
              双端队列容器赋值函数。
            </p>
            <ul class="bs-docs-subtitle"><li>函数原型</li></ul>
<pre class="prettyprint">
void deque_assign(deque_t* pdeq_dest, const deque_t* cpdeq_src);
</pre>
		        <ul class="bs-docs-subtitle"><li>参数说明</li></ul>
            <table class="table table-condensed">
              <tr>
                <th>pdeq_dest:</th>
                <td>被赋值的双端队列容器。</td>
              </tr>
              <tr>
                <th>cpdeq_src:</th>
                <td>赋值的双端队列容器。</td>
              </tr>
            </table>
            <ul class="bs-docs-subtitle"><li>备注</li></ul>
            <p>
              两个deque_t容器都必须是已经初始化的，否则函数的行为是未定义的。
              两个deque_t容器中包含的数据类型必须一致，否则函数的行为是未定义的。
              赋值之后两个容器内容相同。
            </p>
            <ul class="bs-docs-subtitle"><li>前提条件</li></ul>
            <p>
              包含头文件&lt;cstl/cdeque.h&gt;
            </p>
            <ul class="bs-docs-subtitle"><li>版本</li></ul>
            <p>
              所有版本。
            </p>
            <ul class="bs-docs-subtitle"><li>示例代码</li></ul>
            <div class="code-example">
              <a title="download sample code" href="/codes/manual/deque_assign.c">
                <i class="icon-download-alt"></i>
              </a>
<pre class="prettyprint linenums">
/*
 * deque_assign.c
 */

#include &lt;stdio.h&gt;
#include &lt;cstl/cdeque.h&gt;

int main(int argc, char* argv[])
{
    deque_t*            pdeq1 = NULL;
    deque_t*            pdeq2 = NULL;
    deque_iterator_t    it;

    if ((pdeq1 = create_deque(int)) == NULL) {
        return -1;
    }
    if ((pdeq2 = create_deque(int)) == NULL) {
        deque_destroy(pdeq1);
        return -1;
    }

    deque_init(pdeq1);
    deque_push_back(pdeq1, 10);
    deque_push_back(pdeq1, 20);
    deque_push_back(pdeq1, 30);

    deque_init(pdeq2);
    deque_push_back(pdeq2, 40);
    deque_push_back(pdeq2, 50);

    printf("deq1 = ");
    for (it = deque_begin(pdeq1);
         !iterator_equal(it, deque_end(pdeq1));
         it = iterator_next(it)) {
        printf("%d ", *(int*)iterator_get_pointer(it));
    }
    printf("\n");
    
    printf("deq2 = ");
    for (it = deque_begin(pdeq2);
         !iterator_equal(it, deque_end(pdeq2));
         it = iterator_next(it)) {
        printf("%d ", *(int*)iterator_get_pointer(it));
    }
    printf("\n");

    deque_assign(pdeq1, pdeq2);

    printf("deq1 = ");
    for (it = deque_begin(pdeq1);
         !iterator_equal(it, deque_end(pdeq1));
         it = iterator_next(it)) {
        printf("%d ", *(int*)iterator_get_pointer(it));
    }
    printf("\n");
    
    printf("deq2 = ");
    for (it = deque_begin(pdeq2);
         !iterator_equal(it, deque_end(pdeq2));
         it = iterator_next(it)) {
        printf("%d ", *(int*)iterator_get_pointer(it));
    }
    printf("\n");

    deque_destroy(pdeq1);
    deque_destroy(pdeq2);

    return 0;
}
</pre>
            </div>
            <ul class="bs-docs-subtitle"><li>结果输出</li></ul>
<pre class="prettyprint">
deq1 = 10 20 30 
deq2 = 40 50 
deq1 = 40 50 
deq2 = 40 50 
</pre>
          </section>

          <!-- deque_assign_array -->
          <section id="deque_assign_array">
            <div class="page-header">
              <h1>deque_assign_array</h1>
            </div>
            <ul class="bs-docs-subtitle"><li>函数描述</li></ul>
            <p>
              使用指定的数组对双端队列容器赋值。
            </p>
            <ul class="bs-docs-subtitle"><li>函数原型</li></ul>
<pre class="prettyprint">
void deque_assign_array(deque_t* pdeq_deque, const void* cpv_array, size_t t_count);
</pre>
		        <ul class="bs-docs-subtitle"><li>参数说明</li></ul>
            <table class="table table-condensed">
              <tr>
                <th>pdeq_deque:</th>
                <td>被赋值的双端队列容器。</td>
              </tr>
              <tr>
                <th>cpv_array:</th>
                <td>赋值的数组。</td>
              </tr>
              <tr>
                <th>t_count:</th>
                <td>数组元素个数。</td>
              </tr>
            </table>
            <ul class="bs-docs-subtitle"><li>备注</li></ul>
            <p>
              pdeq_deque必须已经初始化，否则函数的行为未定义。
              cpv_array中包含的数据类型必须与pdeq_deque中的数据类型一致，否则函数的行为未定义。
            </p>
            <ul class="bs-docs-subtitle"><li>前提条件</li></ul>
            <p>
              包含头文件&lt;cstl/cdeque.h&gt;
            </p>
            <ul class="bs-docs-subtitle"><li>版本</li></ul>
            <p>
              2.1+
            </p>
            <ul class="bs-docs-subtitle"><li>示例代码</li></ul>
            <div class="code-example">
              <a title="download sample code" href="/codes/manual/deque_assign_array.c">
                <i class="icon-download-alt"></i>
              </a>
<pre class="prettyprint linenums">
/*
 * deque_assign_array.c
 */

#include &lt;stdio.h&gt;
#include &lt;cstl/cdeque.h&gt;

int main(int argc, char* argv[])
{
    deque_t*            pdeq = create_deque(int);
    deque_iterator_t    it;
    int                 an_array[] = {3, 90, -88, 2, 764, -92, 0, 1234, -2367, 4};

    if (pdeq == NULL) {
        return -1;
    }

    deque_init(pdeq);
    deque_push_back(pdeq, 100);
    deque_push_back(pdeq, 200);
    deque_push_back(pdeq, 300);

    printf("deq = ");
    for (it = deque_begin(pdeq);
         !iterator_equal(it, deque_end(pdeq));
         it = iterator_next(it)) {
        printf("%d ", *(int*)iterator_get_pointer(it));
    }
    printf("\n");

    deque_assign_array(pdeq, an_array, 10);

    printf("deq = ");
    for (it = deque_begin(pdeq);
         !iterator_equal(it, deque_end(pdeq));
         it = iterator_next(it)) {
        printf("%d ", *(int*)iterator_get_pointer(it));
    }
    printf("\n");

    deque_destroy(pdeq);

    return 0;
}
</pre>
            </div>
            <ul class="bs-docs-subtitle"><li>结果输出</li></ul>
<pre class="prettyprint">
deq = 100 200 300 
deq = 3 90 -88 2 764 -92 0 1234 -2367 4 
</pre>
          </section>

          <!-- deque_assign_elem -->
          <section id="deque_assign_elem">
            <div class="page-header">
              <h1>deque_assign_elem</h1>
            </div>
            <ul class="bs-docs-subtitle"><li>函数描述</li></ul>
            <p>
              使用指定的数据对双端队列容器赋值。
            </p>
            <ul class="bs-docs-subtitle"><li>函数原型</li></ul>
<pre class="prettyprint">
void deque_assign_elem(deque_t* pdeq_deque, size_t t_count, elem);
</pre>
		        <ul class="bs-docs-subtitle"><li>参数说明</li></ul>
            <table class="table table-condensed">
              <tr>
                <th>pdeq_deque:</th>
                <td>被赋值的双端队列容器。</td>
              </tr>
              <tr>
                <th>t_count:</th>
                <td>指定数据的个数。</td>
              </tr>
              <tr>
                <th>elem:</th>
                <td>指定数据。</td>
              </tr>
            </table>
            <ul class="bs-docs-subtitle"><li>备注</li></ul>
            <p>
              pdeq_deque必须已经初始化，否则函数的行为未定义。
              elem必须和pdeq_deque中的数据类型相同，否则函数的行为是未定义的。
            </p>
            <ul class="bs-docs-subtitle"><li>前提条件</li></ul>
            <p>
              包含头文件&lt;cstl/cdeque.h&gt;
            </p>
            <ul class="bs-docs-subtitle"><li>版本</li></ul>
            <p>
              所有版本。
            </p>
		        <ul class="bs-docs-subtitle"><li>示例代码</li></ul>
            <div class="code-example">
              <a title="download sample code" href="/codes/manual/deque_assign_elem.c">
                <i class="icon-download-alt"></i>
              </a>
<pre class="prettyprint linenums">
/*
 * deque_assign_elem.c
 */

#include &lt;stdio.h&gt;
#include &lt;cstl/cdeque.h&gt;

int main(int argc, char* argv[])
{
    deque_t*            pdeq = create_deque(int);
    deque_iterator_t    it;

    if (pdeq == NULL) {
        return -1;
    }

    deque_init(pdeq);
    deque_push_back(pdeq, 1);
    deque_push_back(pdeq, 2);
    deque_push_back(pdeq, 3);

    printf("deq = ");
    for (it = deque_begin(pdeq);
         !iterator_equal(it, deque_end(pdeq));
         it = iterator_next(it)) {
        printf("%d ", *(int*)iterator_get_pointer(it));
    }
    printf("\n");

    deque_assign_elem(pdeq, 10, -299);

    printf("deq = ");
    for (it = deque_begin(pdeq);
         !iterator_equal(it, deque_end(pdeq));
         it = iterator_next(it)) {
        printf("%d ", *(int*)iterator_get_pointer(it));
    }
    printf("\n");

    deque_destroy(pdeq);

    return 0;
}
</pre>
            <ul class="bs-docs-subtitle"><li>结果输出</li></ul>
<pre class="prettyprint">
deq = 1 2 3 
deq = -299 -299 -299 -299 -299 -299 -299 -299 -299 -299 
</pre>
          </section>

          <!-- deque_assign_range -->
          <section id="deque_assign_range">
            <div class="page-header">
              <h1>deque_assign_range</h1>
            </div>
            <ul class="bs-docs-subtitle"><li>函数描述</li></ul>
            <p>
              使用指定的数据区间对双端队列容器赋值。
            </p>
            <ul class="bs-docs-subtitle"><li>函数原型</li></ul>
<pre class="prettyprint">
void deque_assign_range(deque_t* pdeq_deque, iterator_t it_begin, iterator_t it_end);
</pre>
            <ul class="bs-docs-subtitle"><li>参数说明</li></ul>
            <table class="table table-condensed">
              <tr>
                <th>pdeq_deque:</th>
                <td>被赋值的双端队列容器。</td>
              </tr>
              <tr>
                <th>it_begin:</th>
                <td>数据区间开始位置迭代器。</td>
              </tr>
              <tr>
                <th>it_end:</th>
                <td>数据区间末尾位置迭代器。</td>
              </tr>
            </table>
            <ul class="bs-docs-subtitle"><li>备注</li></ul>
            <p>
              pdeq_deque必须已经初始化，否则函数的行为未定义。
              [it_begin, it_end)必须是有效的数据区间，否则函数的行为是未定义的。
              [it_begin, it_end)可以是非deque_t类型的数据区间。
              [it_begin, it_end)包含的数据类型必须与pdeq_deque中的数据类型相同，否则函数的行为是未定义的。
            </p>
            <ul class="bs-docs-subtitle"><li>前提条件</li></ul>
            <p>
                包含头文件&lt;cstl/cdeque.h&gt;
            </p>
            <ul class="bs-docs-subtitle"><li>版本</li></ul>
            <p>
              所有版本。
            </p>
            <ul class="bs-docs-subtitle"><li>示例代码</li></ul>
            <div class="code-example">
              <a title="download sample code" href="/codes/manual/deque_assign_range.c">
                <i class="icon-download-alt"></i>
              </a>
<pre class="prettyprint linenums">
/*
 * deque_assign_range.c
 */

#include &lt;stdio.h&gt;
#include &lt;cstl/cdeque.h&gt;
#include &lt;cstl/cset.h&gt;

int main(int argc, char* argv[])
{
    deque_t*            pdeq_dest = NULL;
    deque_t*            pdeq_src = NULL;
    set_t*              pset = NULL;
    deque_iterator_t    it;
    int                 i;

    if ((pdeq_dest = create_deque(int)) == NULL) {
        return -1;
    }
    if ((pdeq_src = create_deque(int)) == NULL) {
        deque_destroy(pdeq_dest);
        return -1;
    }
    if ((pset = create_set(int)) == NULL) {
        deque_destroy(pdeq_dest);
        deque_destroy(pdeq_src);
        return -1;
    }

    deque_init(pdeq_dest);
    for (i = 0; i &lt; 10; ++i) {
        deque_push_back(pdeq_dest, i);
    }

    printf("pdeq = ");
    for (it = deque_begin(pdeq_dest);
         !iterator_equal(it, deque_end(pdeq_dest));
         it = iterator_next(it)) {
        printf("%d ", *(int*)iterator_get_pointer(it));
    }
    printf("\n");

    deque_init(pdeq_src);
    for (i = 100; i &lt; 1000; i += 100) {
        deque_push_front(pdeq_src, i);
    }

    deque_assign_range(pdeq_dest, deque_begin(pdeq_src), deque_end(pdeq_src));

    printf("pdeq = ");
    for (it = deque_begin(pdeq_dest);
         !iterator_equal(it, deque_end(pdeq_dest));
         it = iterator_next(it)) {
        printf("%d ", *(int*)iterator_get_pointer(it));
    }
    printf("\n");

    set_init(pset);
    for (i = -10; i &lt; 11; ++i) {
        set_insert(pset, i);
    }

    deque_assign_range(pdeq_dest, set_begin(pset), set_end(pset));

    printf("pdeq = ");
    for (it = deque_begin(pdeq_dest);
         !iterator_equal(it, deque_end(pdeq_dest));
         it = iterator_next(it)) {
        printf("%d ", *(int*)iterator_get_pointer(it));
    }
    printf("\n");

    deque_destroy(pdeq_dest);
    deque_destroy(pdeq_src);
    set_destroy(pset);

    return 0;
}
</pre>
            </div>
            <ul class="bs-docs-subtitle"><li>结果输出</li></ul>
<pre class="prettyprint">
pdeq = 0 1 2 3 4 5 6 7 8 9 
pdeq = 900 800 700 600 500 400 300 200 100 
pdeq = -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 
</pre>
          </section>

          <!-- deque_at -->
          <section id="deque_at">
            <div class="page-header">
              <h1>deque_at</h1>
            </div>
            <ul class="bs-docs-subtitle"><li>函数描述</li></ul>
            <p>
              使用下标对双端队列容器中的数据进行访问。
            </p>
            <ul class="bs-docs-subtitle"><li>函数原型</li></ul>
<pre class="prettyprint">
void* deque_at(const deque_t* cpdeq_deque, size_t t_pos);
</pre>
            <ul class="bs-docs-subtitle"><li>参数说明</li></ul>
            <table class="table table-condensed">
              <tr>
                <th>cpdeq_deque:</th>
                <td>被访问的双端队列容器。</td>
              </tr>
              <tr>
                <th>t_pos:</th>
                <td>访问的数据下标。</td>
              </tr>
            </table>
            <ul class="bs-docs-subtitle"><li>备注</li></ul>
            <p>
              deque_at返回指向被访问的数据的指针。
              cpdeq_deque必须已经初始化，否则函数的行为未定义。
              t_pos必须是有效的下标，否则函数的行为是未定义的。
            </p>
            <ul class="bs-docs-subtitle"><li>前提条件</li></ul>
            <p>
              包含头文件&lt;cstl/cdeque.h&gt;
            </p>
            <ul class="bs-docs-subtitle"><li>版本</li></ul>
            <p>
              所有版本。
            </p>
            <ul class="bs-docs-subtitle"><li>示例代码</li></ul>
            <div class="code-example">
              <a title="download sample code" href="/codes/manual/deque_at.c">
                <i class="icon-download-alt"></i>
              </a>
<pre class="prettyprint linenums">
/*
 * deque_at.c
 */

#include &lt;stdio.h&gt;
#include &lt;cstl/cdeque.h&gt;

int main(int argc, char* argv[])
{
    deque_t*    pdeq = create_deque(int);
    int         i = 0;

    if (pdeq == NULL) {
        return -1;
    }

    deque_init_n(pdeq, 10);

    printf("pdeq = ");
    for (i = 0; i &lt; deque_size(pdeq); ++i) {
        printf("%d ", *(int*)deque_at(pdeq, i));
    }
    printf("\n");

    for (i = 0; i &lt; deque_size(pdeq); ++i) {
        *(int*)deque_at(pdeq, i) += 100 * i;
    }

    printf("pdeq = ");
    for (i = 0; i &lt; deque_size(pdeq); ++i) {
        printf("%d ", *(int*)deque_at(pdeq, i));
    }
    printf("\n");

    deque_destroy(pdeq);

    return 0;
}
</pre>
            <ul class="bs-docs-subtitle"><li>结果输出</li></ul>
<pre class="prettyprint">
pdeq = 0 0 0 0 0 0 0 0 0 0 
pdeq = 0 100 200 300 400 500 600 700 800 900 
</pre>
          </section>

          <!-- deque_back -->
          <section id="deque_back">
            <div class="page-header">
              <h1>deque_back</h1>
            </div>
            <ul class="bs-docs-subtitle"><li>函数描述</li></ul>
            <p>
              访问双向队列容器中的最后一个数据。
            </p>
            <ul class="bs-docs-subtitle"><li>函数原型</li></ul>
<pre class="prettyprint">
void* deque_back(const deque_t* cpdeq_deque);
</pre>
            <ul class="bs-docs-subtitle"><li>参数说明</li></ul>
            <table class="table table-condensed">
              <tr>
                <th>cpdeq_deque:</th>
                <td>双端队列容器。</td>
              </tr>
            </table>
            <ul class="bs-docs-subtitle"><li>备注</li></ul>
            <p>
              deque_back返回指向容器中最后一个数据的指针。
              cpdeq_deque必须已经初始化，否则函数的行为未定义。
              cpdeq_deque必须不能为空，否则函数的行为是未定义的。
            </p>
            <ul class="bs-docs-subtitle"><li>前提条件</li></ul>
            <p>
              包含头文件&lt;cstl/cdeque.h&gt;
            </p>
            <ul class="bs-docs-subtitle"><li>版本</li></ul>
            <p>
              所有版本。
            </p>
            <ul class="bs-docs-subtitle"><li>示例代码</li></ul>
            <div class="code-example">
              <a title="download sample code" href="/codes/manual/deque_back.c">
                <i class="icon-download-alt"></i>
              </a>
<pre class="prettyprint linenums">
/*
 * deque_back.c
 */

#include &lt;stdio.h&gt;
#include &lt;cstl/cdeque.h&gt;

int main(int argc, char* argv[])
{
    deque_t* pdeq = create_deque(int);
    int*     pn_i = NULL;
    int*     pn_j = NULL;

    if (pdeq == NULL) {
        return -1;
    }

    deque_init(pdeq);
    deque_push_back(pdeq, 10);
    deque_push_back(pdeq, 11);

    pn_i = (int*)deque_back(pdeq);
    pn_j = (int*)deque_back(pdeq);

    printf("The last integer of pdeq is %d\n", *pn_i);
    (*pn_i)++;
    printf("The modified last integer of pdeq is %d\n", *pn_j);

    deque_destroy(pdeq);

    return 0;
}
</pre>
            <ul class="bs-docs-subtitle"><li>结果输出</li></ul>
<pre class="prettyprint">
The last integer of pdeq is 11
The modified last integer of pdeq is 12
</pre>
          </section>

          <!-- deque_begin -->
          <section id="deque_begin">
            <div class="page-header">
              <h1>deque_begin</h1>
            </div>
            <ul class="bs-docs-subtitle"><li>函数描述</li></ul>
            <p>
              返回指向双端队列容器中第一个数据的迭代器。
            </p>
            <ul class="bs-docs-subtitle"><li>函数原型</li></ul>
<pre class="prettyprint">
deque_iterator_t deque_begin(const deque_t* cpdeq_deque);
</pre>
            <ul class="bs-docs-subtitle"><li>参数说明</li></ul>
            <table class="parameter">
              <tr>
                <th>cpdeq_deque:</th>
                <td>双端队列容器。</td>
              </tr>
            </table>
            <ul class="bs-docs-subtitle"><li>备注</li></ul>
            <p>
              deque_begin返回指向容器中第一个数据的迭代器。
              cpdeq_deque必须已经初始化，否则函数的行为未定义。
              如果cpdeq_deque为空，返回值与deque_end(cpdeq_deque)相等。
            </p>
            <ul class="bs-docs-subtitle"><li>前提条件</li></ul>
            <p>
              包含头文件&lt;cstl/cdeque.h&gt;
            </p>
            <ul class="bs-docs-subtitle"><li>版本</li></ul>
            <p>
              所有版本。
            </p>
            <ul class="bs-docs-subtitle"><li>示例代码</li></ul>
            <div class="code-example">
              <a title="download sample code" href="/codes/manual/deque_begin.c">
                <i class="icon-download-alt"></i>
              </a>
<pre class="prettyprint linenums">
/*
 * deque_begin.c
 */

#include &lt;stdio.h&gt;
#include &lt;cstl/cdeque.h&gt;

int main(int argc, char* argv[])
{
    deque_t*            pdeq = create_deque(int);
    deque_iterator_t    it;

    if (pdeq == NULL) {
        return -1;
    }

    deque_init(pdeq);
    deque_push_back(pdeq, 1);
    deque_push_back(pdeq, 2);

    it = deque_begin(pdeq);
    printf("The first element in pdeq is %d\n", *(int*)iterator_get_pointer(it));
    *(int*)iterator_get_pointer(it) = 20;
    printf("The first element in pdeq is now %d\n", *(int*)iterator_get_pointer(it));

    deque_destroy(pdeq);

    return 0;
}
</pre>
            <ul class="bs-docs-subtitle"><li>结果输出</li></ul>
<pre class="prettyprint">
The first element in pdeq is 1
The first element in pdeq is now 20
</pre>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- TODO -->
          <section id="TODO">
            <div class="page-header">
              <h1>TODO</h1>
            </div>
            <p>
            </p>
          </section>

          <!-- deque_swap -->
          <section id="deque_swap">
            <div class="page-header">
              <h1>deque_swap</h1>
            </div>
            <ul class="bs-docs-subtitle"><li>函数描述</li></ul>
            <p>
              交换两个双端队列容器中的数据。
            </p>
            <ul class="bs-docs-subtitle"><li>函数原型</li></ul>
<pre class="prettyprint">
void deque_size(deque_t* pdeq_first, deque_t* pdeq_second);
</pre>
            <ul class="bs-docs-subtitle"><li>参数说明</li></ul>
            <table class="table table-condensed">
              <tr>
                <th>pdeq_first:</th>
                <td>第一个双端队列容器。</td>
              </tr>
              <tr>
                <th>pdeq_second:</th>
                <td>第二个双端队列容器。</td>
              </tr>
            </table>
            <ul class="bs-docs-subtitle"><li>备注</li></ul>
            <p>
              pdeq_first和pdeq_second必须有效的双端队列容器，否则函数行为未定义。
              pdeq_first和pdeq_second保存的数据类型必须是一致的，否则函数的行为是未定义的。
            </p>
            <ul class="bs-docs-subtitle"><li>前提条件</li></ul>
            <p>
              包含头文件&lt;cstl/cdeque.h&gt;
            </p>
            <ul class="bs-docs-subtitle"><li>版本</li></ul>
            <p>
              所有版本。
            </p>
            <ul class="bs-docs-subtitle"><li>示例代码</li></ul>
            <div class="code-example">
              <a title="download sample code" href="/codes/manual/deque_swap.c">
                <i class="icon-download-alt"></i>
              </a>
<pre class="prettyprint linenums">
/*
 * deque_swap.c
 */

#include &lt;stdio.h&gt;
#include &lt;cstl/cdeque.h&gt;

int main(int argc, char* argv[])
{
    deque_t*         pdeq_q1 = NULL;
    deque_t*         pdeq_q2 = NULL;
    deque_iterator_t it;

    if ((pdeq_q1 = create_deque(int)) == NULL) {
        return -1;
    }
    if ((pdeq_q2 = create_deque(int)) == NULL) {
        deque_destroy(pdeq_q1);
        return -1;
    }

    deque_init(pdeq_q1);
    deque_init(pdeq_q2);
    deque_push_back(pdeq_q1, 1);
    deque_push_back(pdeq_q1, 2);
    deque_push_back(pdeq_q1, 3);
    deque_push_back(pdeq_q2, 10);
    deque_push_back(pdeq_q2, 20);

    printf("The original deque q1 is:");
    for (it = deque_begin(pdeq_q1);
         !iterator_equal(it, deque_end(pdeq_q1));
         it = iterator_next(it)) {
        printf(" %d", *(int*)iterator_get_pointer(it));
    }
    printf("\n");
    printf("The original deque q2 is:");
    for (it = deque_begin(pdeq_q2);
         !iterator_equal(it, deque_end(pdeq_q2));
         it = iterator_next(it)) {
        printf(" %d", *(int*)iterator_get_pointer(it));
    }
    printf("\n");

    deque_swap(pdeq_q1, pdeq_q2);

    printf("After swapping, deque q1 is:");
    for (it = deque_begin(pdeq_q1);
         !iterator_equal(it, deque_end(pdeq_q1));
         it = iterator_next(it)) {
        printf(" %d", *(int*)iterator_get_pointer(it));
    }
    printf("\n");
    printf("After swapping, deque q2 is:");
    for (it = deque_begin(pdeq_q2);
         !iterator_equal(it, deque_end(pdeq_q2));
         it = iterator_next(it)) {
        printf(" %d", *(int*)iterator_get_pointer(it));
    }
    printf("\n");

    deque_destroy(pdeq_q1);
    deque_destroy(pdeq_q2);

    return 0;
}
</pre>
            <ul class="bs-docs-subtitle"><li>结果输出</li></ul>
<pre class="prettyprint">
The original deque q1 is: 1 2 3
The original deque q2 is: 10 20
After swapping, deque q1 is: 10 20
After swapping, deque q2 is: 1 2 3
</pre>
          </section>
        </div>
      </div>

      <hr>
      <footer>
        <p id="copyright">
          &copy; 2008 - 2014
          <a href="http://libcstl.org/">libcstl.org</a>
        </p>
        <p id="github">
          Published with
          <a href="http://pages.github.com">Github Pages</a>
        </p>
      </footer>
    </div>

    <script src="../../javascripts/jquery-1.11.0.min.js"></script>
    <script src="../../bootstrap/js/bootstrap.min.js"></script>
    <script src="../../google-code-prettify/prettify.js"></script>
    <!--<script src="../../javascripts/libcstl.js"></script>-->
  </body>
</html>

